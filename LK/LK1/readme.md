# Лекция 1. Коллекции и итераторы. Модули:
## Сборка мусора:
1) Корневые объекты не могут быть удалены сборщиком мусора. Это:
 - Глобальные переменные;
 - Текущая функция, которая находится на стадии выполнения;
 - Другие функции в текущей цепочке вызовов, их параметры и локальные переменные.
2) Работа сборщика по возможности производится во время простоев работы скрипта;
3) Когда объектов много, сборщик старается разделять их на части (как дерево);
4) Объекты делятся на новые (проверяются чаще) и старые (проверяются реже).
## Тип данных Symbol:
1) Всегда уникальное значение идентификатора;
2) Существуют системные символы. Например, Symbol.hasInstance, Symbol.isConcatSpreadable, Symbol.iterator, Symbol.toPrimitive.
## Итераторы:
1) Итерируемые объекты - это обобщения массивов;
2) Встроенная конструкция Symbol.iterator позволяет создавать итераторы, которые работают по написанному нами коллбеку;
3) У объекта итератора есть метод next();
4) Array.from позволяет создавать массивы из итерируемых объектов.
## Коллекции:
1) Map - это коллекция ключ/значение, как объект. В отличие от объектов, Map позволяет в качестве ключей использовать ключи любого типа:
 - new Map() - создает коллекцию;
 - map.set(key, value) - записывает по ключу key значение value;
 - map.get(key) — возвращает значение по ключу или undefined, если ключ key отсутствует;
 - map.has(key) — возвращает true, если ключ key присутствует в коллекции, иначе false;
 - map.delete(key) — удаляет элемент (пару «ключ/значение») по ключу key;
 - map.clear() — очищает коллекцию от всех элементов;
 - map.size — возвращает текущее количество элементов;
 - map.keys() — возвращает итерируемый объект по ключам
 - map.values() — возвращает итерируемый объект по значениям
 - map.entries() — возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for(..of..)
 - map.forEach() — итератор, работающий так же, как и с массивом.
2) Set - это "множество" значений (без ключей), где каждое значение может появляться только один раз:
 - new Set(iterable) — создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set;
 - set.add(value) — добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set;
 - set.delete(value) — удаляет значение, возвращает true, если value было во множестве на момент вызова, иначе false;
 - set.has(value) — возвращает true, если значение присутствует во множестве, иначе false;
 - set.clear() — удаляет все имеющиеся значения;
 - set.size — возвращает количество элементов во множестве;
 - set.keys() — возвращает итерируемый объект по ключам
 - set.values() — возвращает итерируемый объект по значениям
 - set.entries() — возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for(..of..)
 - set.forEach() — итератор, работающий так же, как и с массивом.
3) WeakMap — это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.
4) WeakSet — это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.
Удаляются объекты автоматически сборщиком мусора. Рассматриваемые коллекции не создают специальных ссылок на эти объекты и не препятствуют их удалению.
Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции. WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.
## Модули:
1) Подключаемые модули — это функционал, который был добавлен недавно. Он работает автоматически в строгом режиме — режиме, который использует последние нововведения языка. Из-за этого какой-то код может сработать неожиданно;
2) Могут возникнуть ошибки CORS при локальной загрузке файлов HTML. Нужно проводить тестирование этих файлов через сервер;
3) В теге script при загрузке модуля по умолчанию устанавливается атрибут defer;
4) Модули подключаются только один раз, даже если есть несколько ссылок в тегах script для их подключения
5) Объекты из модуля добавляются в область видимости одного скрипта. В глобальной области они не видны.
Некоторые дополнительные возможности:
 - Экспорт по умолчанию. Некоторые модули объявляют экспортные объекты с помощью ключевого слова default. Импорты делаются без фигурных скобок — так разработчики решили упростить использование экспортируемого функционала сторонним модулем, а также помогает модулям JavaScript взаимодействовать с существующими модульными системами CommonJS и AMD;
 - Для импорта всех экспортируемых объектов из файла вместо перечисления имён объектов можно указать звёздочку *;
 - Для избежания конфликтов имён в текущем файле можно переименовывать экспортируемые объекты с помощью ключевого слова as;
 - Самая свежая возможность модулей — динамическая загрузка. Выполняется она с помощью промиса import(). Это даёт нам возможность воспользоваться преимуществами ленивой загрузки модулей, когда они загружаются именно тогда, когда они необходимы. Это снижает нагрузку на браузер и облегчает выполнение скриптов.